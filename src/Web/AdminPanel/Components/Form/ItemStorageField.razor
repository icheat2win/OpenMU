@using System.ComponentModel.DataAnnotations
@using System.Diagnostics.CodeAnalysis
@using Microsoft.Extensions.Logging
@using MUnique.OpenMU.DataModel
@using MUnique.OpenMU.DataModel.Configuration
@using MUnique.OpenMU.DataModel.Entities
@using MUnique.OpenMU.Persistence
@using MUnique.OpenMU.Web.ItemEditor
@using MUnique.OpenMU.Web.AdminPanel.Components.ItemEdit;

@inherits NotifyableInputBase<ItemStorage>

<style>
    /* Modern ItemStorage styling with Dark Mode */
    .item-storage-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 1rem;
        padding: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    html.dark .item-storage-container {
        background: linear-gradient(135deg, #4338ca 0%, #6b21a8 100%);
    }
    
    /* Toast Notification System */
    .toast-container {
        position: fixed;
        top: 24px;
        right: 24px;
        z-index: 9999;
        pointer-events: none;
    }
    
    .toast {
        pointer-events: auto;
        min-width: 320px;
        max-width: 480px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        padding: 16px 20px;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-left: 4px solid;
        backdrop-filter: blur(12px);
        background: rgba(255, 255, 255, 0.95);
    }
    
    html.dark .toast {
        background: rgba(30, 41, 59, 0.95);
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
    }
    
    .toast-success {
        border-left-color: #10b981;
    }
    
    .toast-error {
        border-left-color: #ef4444;
    }
    
    .toast-info {
        border-left-color: #3b82f6;
    }
    
    .toast-warning {
        border-left-color: #f59e0b;
    }
    
    .toast-icon {
        font-size: 24px;
        line-height: 1;
        flex-shrink: 0;
    }
    
    .toast-content {
        flex: 1;
        font-size: 14px;
        font-weight: 500;
        color: #1f2937;
    }
    
    html.dark .toast-content {
        color: #f1f5f9;
    }
    
    .toast-close {
        background: transparent;
        border: none;
        color: #6b7280;
        cursor: pointer;
        font-size: 20px;
        line-height: 1;
        padding: 4px;
        flex-shrink: 0;
        transition: all 0.2s ease;
        border-radius: 6px;
    }
    
    .toast-close:hover {
        background: rgba(0, 0, 0, 0.05);
        color: #374151;
    }
    
    html.dark .toast-close {
        color: #9ca3af;
    }
    
    html.dark .toast-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #d1d5db;
    }
    
    @keyframes slideInRight {
        from {
            transform: translateX(400px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    .toast.fade-out {
        animation: fadeOut 0.3s ease-out forwards;
    }
    
    @keyframes fadeOut {
        to {
            opacity: 0;
            transform: translateX(400px);
        }
    }
    
    .equipped-box {
        background: linear-gradient(to bottom, #1e1e2e, #2a2a3e);
        padding: 0.5rem;
        border-radius: 0.5rem;
        border: 2px solid #4a4a6a;
        margin-bottom: 0.5rem;
    }
    
    html.dark .equipped-box {
        background: linear-gradient(to bottom, #0f172a, #1e293b);
        border: 2px solid #475569;
    }
    
    .storage-grid {
        background: transparent;
        border: none;
        padding: 0;
    }
    
    html.dark .storage-grid {
        background: transparent;
        border: none;
    }
    
    .extension-header {
        width: 100%;
        background-color: black;
        color: wheat;
        text-align: center;
        border-top: 1px dashed wheat;
        padding: 0.5rem;
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.875rem;
        letter-spacing: 0.05em;
        margin-top: 0.5rem;
    }
    
    html.dark .extension-header {
        background-color: black;
        color: wheat;
        border-top: 1px dashed wheat;
    }
    
    .action-buttons {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        padding: 0 0.75rem;
    }
    
    .action-buttons button {
        width: 100%;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        font-weight: 600;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }
    
    .btn-create {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }
    
    .btn-create:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(16, 185, 129, 0.6);
    }
    
    html.dark .btn-create {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
    }
    
    .btn-delete {
        background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }
    
    .btn-delete:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(239, 68, 68, 0.6);
    }
    
    .btn-delete:disabled {
        background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);
        cursor: not-allowed;
        opacity: 0.5;
        box-shadow: none;
    }
    
    html.dark .btn-delete:disabled {
        background: linear-gradient(135deg, #475569 0%, #334155 100%);
    }
    
    .item-editor-panel {
        background: white;
        border: 2px solid #e5e7eb;
        border-radius: 0.75rem;
        padding: 1.5rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    html.dark .item-editor-panel {
        background: #1e293b;
        border: 2px solid #475569;
    }
    
    .item-editor-panel h3 {
        color: #1e293b;
        font-size: 1.25rem;
        font-weight: 700;
        margin-bottom: 1rem;
        padding-bottom: 0.75rem;
        border-bottom: 2px solid #e5e7eb;
    }
    
    html.dark .item-editor-panel h3 {
        color: #f1f5f9;
        border-bottom: 2px solid #475569;
    }
    
    /* Icon styling */
    .oi {
        font-size: 1.125rem;
    }
</style>

@if (this.CurrentValue is null)
{
    return;
}

<!-- Toast Notification Container -->
<div class="toast-container">
    @if (!string.IsNullOrEmpty(_saveMessage))
    {
        <div class="toast @_toastType @(_isToastClosing ? "fade-out" : "")">
            <div class="toast-icon">@_toastIcon</div>
            <div class="toast-content">@_saveMessage</div>
            <button class="toast-close" @onclick="CloseToast">×</button>
        </div>
    }
</div>

<div class="item-storage-container">
    @if (!string.IsNullOrEmpty(this._overlappingItemsWarning))
    {
        <div class="bg-red-100 dark:bg-red-900/30 border-l-4 border-red-500 dark:border-red-600 text-red-700 dark:text-red-300 px-6 py-4 mb-4 rounded-lg shadow-lg animate-pulse">
            <div class="flex items-center gap-3">
                <span class="text-2xl">⚠️</span>
                <p class="font-bold text-lg">@_overlappingItemsWarning</p>
            </div>
        </div>
    }
    
    @if (!this.HideLabel)
    {
        <div class="mb-4">
            <FieldLabel Text="@Label" ValueExpression="@this.ValueExpression"/>
        </div>
    }
    <div id="@this.FieldIdentifier.FieldName">
        <div class="flex flex-nowrap w-full gap-4">
            <!-- Left Column: Inventory Grid -->
            <div class="min-w-[336px] max-w-[336px]">
                @if (this._storageType == StorageType.Inventory)
                {
                    <div class="equipped-box mb-2">
                        <EquippedItems
                            @bind-Value="@CurrentValue"
                            SelectedItem="@this._selectedItem"
                            SelectedItemChanged="this.OnSelectedItemChanged"/>
                    </div>
                }
                
                <div class="storage-grid">
                    <MuItemStorage
                        @bind-Value="@CurrentValue"
                        class="@CssClass"
                        StorageType="@this._storageType"
                        NumberOfExtensions="@this._numberOfExtensions"
                        SelectedItem="@this._selectedItem"
                        SelectedItemChanged="this.OnSelectedItemChangedAsync"/>
                </div>
                
                @for (byte i = 0; i < this._numberOfExtensions; i++)
                {
                    <div class="extension-header">
                        <span class="inline-flex items-center gap-2">
                            <span class="text-xl">📦</span>
                            Extension @(i+1)
                        </span>
                    </div>
                    <div class="storage-grid mt-2">
                        <MuItemStorage
                            @bind-Value="@CurrentValue"
                            StorageType="@(this._storageType == StorageType.Inventory ? StorageType.InventoryExtension : StorageType.VaultExtension)"
                            NumberOfExtensions="@this._numberOfExtensions"
                            ExtensionIndex="@i"
                            SelectedItem="@this._selectedItem"
                            SelectedItemChanged="this.OnSelectedItemChangedAsync"/>
                    </div>
                }
                
                @if (this._storageType == StorageType.Inventory)
                {
                    <div class="extension-header">
                        <span class="inline-flex items-center gap-2">
                            <span class="text-xl">🏪</span>
                            Personal Store
                        </span>
                    </div>
                    <div class="storage-grid mt-2">
                        <MuItemStorage
                            @bind-Value="@CurrentValue"
                            StorageType="StorageType.PersonalStore"
                            NumberOfExtensions="@this._numberOfExtensions"
                            SelectedItem="@this._selectedItem"
                            SelectedItemChanged="this.OnSelectedItemChangedAsync"/>
                    </div>
                }
            </div>
            
            <!-- Middle Column: Action Buttons -->
            <div class="action-buttons">
                <button type="button" class="btn-create" @onclick="@this.OnCreateItemClickAsync" title="Create New Item">
                    <span class="oi oi-plus"></span>
                    <span>Create</span>
                </button>
                @if (this._selectedItem is null)
                {
                    <button type="button" class="btn-delete" disabled title="Select an item to delete">
                        <span class="oi oi-trash"></span>
                        <span>Delete</span>
                    </button>
                }
                else
                {
                    <button type="button" class="btn-delete" @onclick="this.OnItemDeleteClickAsync" title="Delete Selected Item">
                        <span class="oi oi-trash"></span>
                        <span>Delete</span>
                    </button>
                }
            </div>
            
            <!-- Right Column: Item Editor -->
            <div class="flex-1">
                @if (this._selectedItem is { })
                {
                    <div class="item-editor-panel">
                        <h3>
                            <span class="inline-flex items-center gap-2">
                                <span>✨</span>
                                @(this._selectedItem.Definition?.Name ?? "Select Item Definition")
                            </span>
                        </h3>
                        <ItemEdit Item="@this._selectedItem" ItemChanged="this.StateHasChanged"></ItemEdit>
                    </div>
                }
                else
                {
                    <div class="item-editor-panel text-center py-12">
                        <span class="text-6xl block mb-4 opacity-50">👆</span>
                        <p class="text-lg text-slate-600">Click an item to edit</p>
                        <p class="text-sm text-slate-500 mt-2">or click Create to add a new item</p>
                    </div>
                }
            </div>
        </div>
    </div>

    <ValidationMessage For=@this.ValueExpression/>
</div>
@if (this._storageType != StorageType.Merchant)
{
    <div class="mt-4">
        <NumberField @bind-Value="@this.CurrentValue.Money" />
    </div>
}

@code {

    /// <summary>
    /// Gets or sets the label which should be displayed. If it's not explicitly provided, the component shows the
    /// Name defined in the <see cref="DisplayAttribute"/>. If there is no Name in a <see cref="DisplayAttribute"/>, it shows the property name instead.
    /// </summary>
    [Parameter]
    public string Label { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets a value indicating if the label should be hidden.
    /// </summary>
    [Parameter]
    public bool HideLabel { get; set; }

    /// <summary>
    /// Gets or sets the persistence context.
    /// </summary>
    [CascadingParameter]
    public IContext PersistenceContext { get; set; } = null!;

    /// <summary>
    /// Gets or sets the logger.
    /// </summary>
    [Inject]
    public ILogger<ItemStorageField> Logger { get; set; } = null!;

    private Item? _selectedItem;

    private StorageType _storageType;

    private byte _numberOfExtensions;
    
    private string? _overlappingItemsWarning;
    
    private string? _saveMessage;
    
    private string? _saveMessageClass;
    
    private string _toastType = "toast-info";
    
    private string _toastIcon = "ℹ️";
    
    private bool _isToastClosing = false;
    
    private System.Threading.Timer? _messageTimer;

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        var model = this.EditContext.Model;
        switch (model)
        {
            case Account account:
                this._storageType = StorageType.Vault;
                this._numberOfExtensions = (byte)(account.IsVaultExtended ? 1 : 0);
                break;
            case Character character:
                this._storageType = StorageType.Inventory;
                this._numberOfExtensions = Math.Min((byte)character.InventoryExtensions, InventoryConstants.MaximumNumberOfExtensions);
                break;
            case MonsterDefinition:
                this._storageType = StorageType.Merchant;
                this._numberOfExtensions = 0;
                break;
            default:
                throw new NotImplementedException($"Unknown owner ({model}) of storage.");
        }
        
        // Check for overlapping items whenever parameters are set
        if (this.Value?.Items != null)
        {
            var hasOverlap = this.HasOverlappingItems(this.Value.Items);
            if (hasOverlap)
            {
                this._overlappingItemsWarning = "⚠️ WARNING: Two or more items are overlapping! This will prevent the client from starting. Please fix the item positions.";
            }
            else
            {
                this._overlappingItemsWarning = null;
            }
        }
    }

    /// <inheritdoc />
    protected override bool TryParseValueFromString(string? value, [MaybeNullWhen(false)] out ItemStorage result, [NotNullWhen(false)] out string? validationErrorMessage)
    {
        result = null;
        validationErrorMessage = "Direct string parsing is not supported for ItemStorage";
        return false;
    }

    /// <inheritdoc />
    protected override string FormatValueAsString(ItemStorage? value)
    {
        return value is null ? string.Empty : $"{value.Items?.Count ?? 0} items, {value.Money} zen";
    }

    private void OnSelectedItemChanged(Item? item)
    {
        this._selectedItem = item;
        this.StateHasChanged();
    }

    private async Task OnSelectedItemChangedAsync(Item? item)
    {
        this._selectedItem = item;
        
        // Auto-save when item is moved
        if (item != null && this.PersistenceContext != null)
        {
            try
            {
                // Validate for overlapping items
                if (this.Value?.Items != null && this.HasOverlappingItems(this.Value.Items))
                {
                    this._overlappingItemsWarning = "⚠️ WARNING: Two or more items are overlapping! This will prevent the client from starting. Please fix the item positions.";
                    ShowToast("Cannot save - Items are overlapping!", "error");
                    Logger.LogWarning("❌ Cannot save inventory - items are overlapping");
                    this.StateHasChanged();
                    return;
                }

                this._overlappingItemsWarning = null;
                ShowToast("Saving changes...", "info");
                Logger.LogInformation("💾 Saving inventory changes...");
                
                await this.PersistenceContext.SaveChangesAsync();
                
                ShowToast("Items saved successfully!", "success", 2500);
                Logger.LogInformation("✅ Inventory saved successfully");
            }
            catch (Exception ex)
            {
                ShowToast($"Failed to save: {ex.Message}", "error", 5000);
                Logger.LogError(ex, "❌ Failed to save inventory changes");
            }
        }
        
        this.StateHasChanged();
    }

    private void ShowToast(string message, string type = "info", int autoHideDuration = 3000)
    {
        _saveMessage = message;
        _isToastClosing = false;
        
        // Set toast type and icon
        switch (type)
        {
            case "success":
                _toastType = "toast-success";
                _toastIcon = "✅";
                break;
            case "error":
                _toastType = "toast-error";
                _toastIcon = "❌";
                break;
            case "warning":
                _toastType = "toast-warning";
                _toastIcon = "⚠️";
                break;
            default:
                _toastType = "toast-info";
                _toastIcon = "💾";
                break;
        }
        
        InvokeAsync(StateHasChanged);
        
        // Auto-hide after duration
        _messageTimer?.Dispose();
        _messageTimer = new System.Threading.Timer(_ =>
        {
            InvokeAsync(() =>
            {
                _isToastClosing = true;
                StateHasChanged();
                
                // Wait for fade-out animation, then clear
                System.Threading.Timer? clearTimer = null;
                clearTimer = new System.Threading.Timer(__ =>
                {
                    _saveMessage = string.Empty;
                    _isToastClosing = false;
                    StateHasChanged();
                    clearTimer?.Dispose();
                }, null, 300, System.Threading.Timeout.Infinite);
            });
        }, null, autoHideDuration, System.Threading.Timeout.Infinite);
    }
    
    private void CloseToast()
    {
        _messageTimer?.Dispose();
        _isToastClosing = true;
        StateHasChanged();
        
        // Wait for animation, then clear
        System.Threading.Timer? clearTimer = null;
        clearTimer = new System.Threading.Timer(_ =>
        {
            _saveMessage = string.Empty;
            _isToastClosing = false;
            StateHasChanged();
            clearTimer?.Dispose();
        }, null, 300, System.Threading.Timeout.Infinite);
    }

    private void ShowMessage(string message, string cssClass)
    {
        // Legacy method - redirect to toast
        string type = "info";
        if (cssClass.Contains("green")) type = "success";
        else if (cssClass.Contains("red")) type = "error";
        else if (cssClass.Contains("yellow") || cssClass.Contains("orange")) type = "warning";
        
        ShowToast(message.Replace("✅ ", "").Replace("❌ ", "").Replace("⚠️ ", "").Replace("💾 ", ""), type);
    }

    private bool HasOverlappingItems(IEnumerable<Item> items)
    {
        var occupiedSlots = new Dictionary<byte, Item>();
        var hasOverlap = false;
        
        foreach (var item in items)
        {
            if (item.Definition == null) continue;
            
            var width = item.Definition.Width;
            var height = item.Definition.Height;
            var baseSlot = item.ItemSlot;
            
            // For equipped items (slot >= 0xC0), just check the single slot
            if (baseSlot >= InventoryConstants.FirstEquippableItemSlotIndex)
            {
                if (occupiedSlots.ContainsKey(baseSlot))
                {
                    Logger.LogWarning($"⚠️ Overlap detected at equipped slot {baseSlot}: {item.Definition.Name} overlaps with {occupiedSlots[baseSlot].Definition?.Name}");
                    hasOverlap = true;
                }
                else
                {
                    occupiedSlots[baseSlot] = item;
                }
                continue;
            }
            
            // For inventory items, check all occupied cells based on width/height
            var x = (byte)(baseSlot % InventoryConstants.RowSize);
            var y = (byte)(baseSlot / InventoryConstants.RowSize);
            
            Logger.LogInformation($"🔍 Checking item '{item.Definition.Name}' at slot {baseSlot} (x:{x}, y:{y}) size: {width}x{height}");
            
            for (byte dx = 0; dx < width; dx++)
            {
                for (byte dy = 0; dy < height; dy++)
                {
                    var checkX = (byte)(x + dx);
                    var checkY = (byte)(y + dy);
                    var checkSlot = (byte)(checkY * InventoryConstants.RowSize + checkX);
                    
                    if (occupiedSlots.ContainsKey(checkSlot))
                    {
                        Logger.LogWarning($"⚠️⚠️ OVERLAP DETECTED at slot {checkSlot} (x:{checkX}, y:{checkY}): '{item.Definition.Name}' overlaps with '{occupiedSlots[checkSlot].Definition?.Name}'");
                        hasOverlap = true;
                    }
                    else
                    {
                        occupiedSlots[checkSlot] = item;
                    }
                }
            }
        }
        
        Logger.LogInformation($"Overlap check complete: {(hasOverlap ? "❌ OVERLAPS FOUND" : "✅ No overlaps")}");
        return hasOverlap;
    }

    private async Task OnItemDeleteClickAsync()
    {
        if (this._selectedItem is null)
        {
            return;
        }

        if (this.Value?.Items.Remove(this._selectedItem) is true)
        {
            await this.PersistenceContext.DeleteAsync(this._selectedItem);
        }

        this._selectedItem = null;
    }

    private void OnCreateItemClickAsync()
    {
        if (this.Value is { } itemStorage)
        {
            var item = this.PersistenceContext.CreateNew<Item>();
            itemStorage.Items.Add(item);
            this._selectedItem = item;
        }
    }

    public void Dispose()
    {
        _messageTimer?.Dispose();
    }
}
